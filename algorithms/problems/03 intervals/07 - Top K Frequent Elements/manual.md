# Задача

[347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

## Решение 1 - Time: $O(n)$, Memory: $O(n)$

```go
func topKFrequent(nums []int, k int) (res []int) {
    m := make(map[int]int)
    res = make([]int, 0, k)

    maxFreq := 0
    for _, v := range nums {
        m[v]++

        if maxFreq < m[v] {
            maxFreq = m[v]
        }
    }

    freq := make([][]int, maxFreq+1)

    for v, vFreq := range m {
        freq[vFreq] = append(freq[vFreq], v)
    }

    for i := len(freq) - 1; i >= 0 && k > 0; i-- {
        if len(freq[i]) > 0 {
            res = append(res, freq[i]...)
            k -= len(freq[i])
        }
    }

    return
}
```

### Оценка 

#### По времени: $O(n)$
Где:
* `n` - размер массива `nums`

По шагам:
* подсчет кол-ва уникальных значений в `nums` - $O(n)$
* формирование массива частот - верхняя оценка $O(n)$
* формирование ответа - верхняя оценка $O(n)$

Таким образом верхняя оценка $O(n)$.



#### По памяти: $O(n)$
Где:
* `n` - размер массива `nums`

Худший случай:
* мапа для подсчета кол-ва уникальных элементов массива `nums` - $O(n)$
* на массив частот - $O(n)$

### Описание решения

1. Считаем сколько каждый элемент встречается в массиве `nums`, с помощью мапы:
	* ключ - значение элемента массива `nums`
	* значение - кол-во сколько этот элемент встречается в `nums`
1. Так как кол-во элементов в массиве `nums`, по условию задачи, небольшое - отводим непрерывный массив, кол-во элементов равно максимальной частоте полученной на предыдущем шаге. Будем использовать его в качестве мапы:
	* ключ/индекс массива - значение частоты 
	* значение элемента - список элементов массива `nums` с данной частотой
1. Проходим по массиву полученному на предыдущем шаге - перебирая все значения частот от большей к меньшей и добавляем в результат все элементы, пока в результате не будет `k` самых частых элементов массива `nums`