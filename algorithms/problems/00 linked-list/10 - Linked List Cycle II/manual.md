# Задача

[142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)

## Решение 1 - Time: $O(n)$, Memory: $O(1)$

```go
func detectCycle(head *ListNode) *ListNode {
    crossPoint := fastAndSlowCross(head)
    
    for crossPoint != nil && crossPoint != head {
        head, crossPoint = head.Next, crossPoint.Next
    }
    
    return crossPoint
}

func fastAndSlowCross(head *ListNode) *ListNode {
    fast := head
    slow := head
 
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
        
        if fast == slow && slow != nil {
            return slow
        }
    }
    
    return nil
}
```

### Оценка 

#### По времени: $O(n)$
Где:
* `n` - кол-во элементов в списке `head`

Медленный указатель пройдет по всем элементам списка, отсюда сложность по времени $O(n)$.

#### По памяти: $O(1)$
Дополнительной памяти не потребовалось. Затраты по памяти не зависят от входных данных. 

### Описание решения

Решается методом двух указателей:
1. обычный
1. быстрый - движется в 2 раза быстрее обычного

Когда быстрый и медленный столкнутся в цикле, расстояние от начала списка до начала цикла и расстояние от точки столкновения до начала цикла будут совпадать. Можно порисовать как будут себя вести указатели, когда добавляешь по одному элементу списка перед циклом. Таким образом если потом идти от начала списка и от точки столкновения - рано или поздно пути пересекутся и это и будет элементом, где начинается цикл.

1. Запускаем два указателя: быстрый и медленный
2. Находим элемент, где пересекутся быстрый и медленный указатели (это может произойти только внутри цикла)
3. Начинаем идти сначала списка и от точки пересечения. Идем пока оба указателя не будут указывать на один и тот же элемент цикла - это и будет началом цикла.