# Задача

[1019. Next Greater Node In Linked List](https://leetcode.com/problems/next-greater-node-in-linked-list/)

## Решение 1 - Time: O(n), Memory: O(n)

```go
func nextLargerNodes(head *ListNode) (res []int) {
    res = make([]int, length(head))
    
    var stack []int
    stackTop := -1
    
    for i := 0 ; head != nil; i, head = i+1, head.Next {
        res[i] = head.Val
        
        if stackTop < 0 || res[stack[stackTop]] >= head.Val {
            stackTop++

            if stackTop == len(stack) {
                stack = append(stack, i)
            } else {
                stack[stackTop] = i
            }
            continue
        }
        if stackTop + 1 != len(res) {
            for ; stackTop >= 0 && res[stack[stackTop]] < head.Val; stackTop-- {
                res[stack[stackTop]] = head.Val
            }
        }

        stackTop++
        stack[stackTop] = i
    }

    for ; stackTop >= 0; stackTop-- {
        res[stack[stackTop]] = 0
    }

    return
}

func length(head *ListNode) (res int) {
    for ; head != nil ; head = head.Next{
        res++
    }

    return 
}
```

### Оценка 

#### По времени: `O(n)`
Где:
* `n` - длина списка `head`

Составные части алгоритма:
* Определение длины списка - `O(n)`
* Последующий проход по списку для вычисления целевых значений - `O(n)`
* Значения элементов списка хранятся в результирующем массиве, пока для них не найден искомый элемент (пока они находятся в стеке). В худшем случае (когда на вход подается убывающая последовательность чисел) - к концу работы алгоритма в стеке окажутся все элементы списка. Для всех элементов стека нужно в результирующем массиве нужно будет проставить в качестве ответа - `0`. Сложность худшего случая - `O(n)`.

Таким образом `O(n + n + n) `= `O(n)`

#### По памяти: `O(n)`
Где:
* `n` - длина списка `head`

Нужно выделить память под стек. Худший случай - список состоит из элементов отсортированных по убыванию. В таком случае в стеке окажутся все элементы из списка и сложность - `O(n)`.

### Описание решения

1. Определяем длину списка, чтобы выделить память под результат
1. Идем по списку
	1. Накапливаем в стеке элементы списка, значение которого меньше предыдущего в стеке. Проще говоря пока значения убывают - накапливаем их в стеке.
	1. Как только тренд на уменьшения закончился, извлекаем из стека значения до тех пор пока текущий элемент списка больше того что в стеке
		* текущий элемент - искомый элемент для всех элементов, что были извлечены из стека
	1. Добавляем текущий элемент в стек
1. Как пройдем по всему списку в стеке останутся элементы целевые значения для которых не были найдены - для них нужно в результате проставить `0`.

## Решение 2 - Time: O($n^2$), Memory: O(1)

```go
func nextLargerNodes(head *ListNode) (res []int) {
    res = make([]int, 0, length(head))

    loop:
    for ; head != nil; head = head.Next {
        for p := head.Next; p != nil; p = p.Next {
            if head.Val < p.Val {
                res = append(res, p.Val)
                continue loop
            }
        }
        
        res = append(res, 0)
    }
    
    return 
}

func length(head *ListNode) (res int) {
    for ; head != nil; head = head.Next {
        res++
    }
    return
}
```

### Оценка 

#### По времени: O($n^2$)
Где:
* `n` - длина списка `head`

В худшем случае для каждого элемента массива придется пробежать список до самого конца. В таком случае - `O(n * (n - 1))` = O($n^2$)

#### По памяти: `O(1)`

Результирующий массив не включен в оценку.

### Описание решения

Для каждого элемента пробегаем вперед, пока не встретим элемент списка с большим значением.