# Задача

[1. Two Sum](https://leetcode.com/problems/two-sum/)

## Решение 1 - Time: $O(n)$, Memory: $O(n)$

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int, len(nums))

    for i, v := range nums {
        if anotherId, exists := m[target - v]; exists {
            return []int{anotherId, i}
        }

        m[v] = i
    }

    return nil
}
```

### Оценка 

#### По времени: $O(n)$
Где:
* `n` - размер списка `nums`

делаем `1` проход по массиву, который образует `n` итераций, а на каждой итерации работаем со словарем, поиск и вставка в словаре работают за $O(1)$, поэтому оценка по времени $O(n)$

#### По памяти: $O(n)$
Где:
* `n` - размер списка `nums`

Самый худший случай, когда ответ - последние `2` элемента. В этом случае у нас в словаре будут находится `n-1` элементов, поэтому оценка по памяти $O(n)$ ($O(n)$, а не $O(n-1)$ т к в `big O` нотации константы принято опускать)

### Описание решения

Используем словарь для хранения позиции каждого элемента, где ключ - значение элементы массива, значение - позиция элемента. Eсли находим в словаре элемент равный `target` - `nums[i]`, значит есть пара дающая в сумме `target` и возвращаем позицию элементов.